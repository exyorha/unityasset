#!/usr/bin/env ruby

require_relative 'class_database_types'

require 'optparse'

BUILTIN_TYPES = {
    "SInt8" => "int8_t",
    "UInt8" => "uint8_t",
    "char" => "uint8_t", # Probably UTF-8 byte
    "bool" => "bool",

    "SInt16" => "int16_t",
    "UInt16" => "uint16_t",

    "int" => "int32_t",
    "unsigned int" => "uint32_t",
    "float" => "float",
    "Type*" => "uint32_t", # no idea what this is, but apparently it's supposed to be 4 byte long

    "SInt64" => "int64_t",
    "UInt64" => "uint64_t",
    "double" => "double",

    "string" => "std::string",
    "pair" => "std::pair",
    "vector" => "std::vector",
    "staticvector" => "std::vector",
    "fixed_bitset" => "std::vector",
    "map" => "UnityMap",
    "set" => "UnitySet",
    "TypelessData" => "UnityTypelessData"
}

ZEROINIT_TYPES = Set[
    "int8_t", "uint8_t", "bool",
    "int16_t", "uint16_t",
    "int32_t", "uint32_t", "float",
    "int64_t", "uint64_t", "double"
]

output_header = nil
output_source = nil

input_cldbs = []
input_types = []
reduced = false

OptionParser.new do |opts|
    opts.banner = "Usage: make_cldb_code.rb <OPTIONS>"

    opts.on("--header HEADER", "Specifies the output header file") do |arg|
        output_header = arg
    end

    opts.on("--source SOURCE", "Specifies the output source file") do |arg|
        output_source = arg
    end

    opts.on("--cldb CLDB", "Use the specified CLDB file as the type information source") do |arg|
        input_cldbs.push arg
    end

    opts.on("--type TYPE", "Use the specified TYPE file generated by ExtractUnityTypeData as the type information source") do |arg|
        input_types.push arg
    end

    opts.on("--reduced", "Generate the types, but not the classes") do
        reduced = true
    end

    opts.on("--help", "Prints this help") do
        puts opts
        exit
    end
end.parse!

if output_header.nil?
    warn "--header must be specified. Try --help"
    exit 1
end

if output_source.nil?
    warn "--source must be specified. Try --help"
    exit 1
end

database = nil

if input_cldbs.size == 1

    database =
        File.open(input_cldbs[0], "rb") do |inf|
            ClassDatabase.new inf
        end

elsif input_types.size > 0

    types = []

    input_types.each do |filename|
        File.open(filename, "rb") do |inf|

            info = UnityTypeInfo.new
            info.read inf
            types.push info
        end
    end

    cldb = StringIO.new
    make_cldb_from_unity_types cldb, types

    cldb.rewind

    database = ClassDatabase.new cldb

else
    warn "Either exactly one '--cldb' must be specified, or one or more '--type' options. Try --help."
    exit 1
end

header = File.open(output_header, "wb")
source = File.open(output_source, "wb")

[ header, source ].each do |file|
    file.write <<EOF
/*
 * This is an automatically-generated Unity serialization type definition
 * class targeting the following versions:
EOF

database.unity_versions.each do |version|
    file.puts " * - #{version}"
end

file.write <<EOF
 */

EOF
end

source.write <<EOF
#include <UnityAsset/UnityTypes.h>
#include <UnityAsset/UnityTypeSerializer.h>

namespace UnityAsset {
EOF

header.write <<EOF
#ifndef UNITY_ASSET_UNITY_CLASSES_H
#define UNITY_ASSET_UNITY_CLASSES_H

#include <cstdint>
#include <utility>
#include <vector>
#include <string>
#include <array>

#include <UnityAsset/SerializedAsset/Downcastable.h>
#include <UnityAsset/SerializedAsset/ExternalAssetData.h>

EOF

unless reduced
    header.puts "#include <UnityAsset/Environment/ObjectPointer.h>"

    header.puts "namespace UnityAsset::UnityClasses {"


    database.classes.each do |classdef|

        header.puts "  struct #{classdef.sanitized_class_name};"

    end

header.puts "}"
end

header.write <<EOF
namespace UnityAsset {
    class UnityTypeSerializer;
    class AssetLinker;
}

namespace UnityAsset::UnityTypes {

  template<typename K, typename V> using UnityMap = std::vector<std::pair<K, V>>;
  template<typename T> using UnitySet = std::vector<T>;
  using UnityTypelessData = std::vector<uint8_t>;

EOF

def compose_type_ref(field, reduced)
    ref = BUILTIN_TYPES.fetch(field.type.type_name, "UnityTypes::#{field.type.type_name}")

    if field.type.template_argument_count != 0 && (!reduced || field.type.type_name != "PPtr")

        arguments = field.template_arguments.map do |argument|
            if argument.kind_of? String
                argument
            else
                compose_type_ref argument, reduced
            end
        end

        ref = "#{ref}<#{arguments.join(", ")}>"
    end

    unless field.array_size.nil?
        ref = "std::array<#{ref}, #{field.array_size}>"
    end

    ref
end

def write_template(type, file)
    if type.template_argument_count != 0
        file.write "  template<"

        (0...type.template_argument_count).each do |index|
            if index != 0
                file.write ", "
            end
            file.write "typename T#{index + 1}"
        end
        file.puts ">"
    end
end

def template_args(type)
    if type.template_argument_count == 0
        ""
    else
        "<#{(1..type.template_argument_count).map { |index| "T#{index}" }.join(", ")}>"
    end
end

database.types.forward_declares.each do |type_name|
    header.puts "  struct #{type_name};"
end

database.types.types.each do |type|
    next if BUILTIN_TYPES.include?(type.type_name) || type.type_name == "Array"

    if type.type_name != "PPtr" || !reduced
        write_template type, header
    end

    header.write "  struct #{type.type_name}";

    if type.type_name == "PPtr" && !reduced
        header.write " final : public ObjectPointer<T1>"
    elsif type.type_name == "StreamingInfo"
        header.write " final : public ExternalAssetData"
    end

    header.puts " {";

    type.fields.each do |field|
        typeref = compose_type_ref field, reduced
        header.write "    #{typeref} #{field.field_name}"

        if ZEROINIT_TYPES.include? typeref
            header.write " = 0"
        end

        header.puts ";"
    end


    header.puts "    void serialize(UnityTypeSerializer &serializer);"

    if type.type_name != "PPtr" || !reduced
        write_template type, source
    end

    source.write "    void UnityTypes::#{type.type_name}"
    if type.type_name != "PPtr" || !reduced
        source.write template_args type
    end

    source.puts "::serialize(UnityTypeSerializer &serializer) {"

    type.fields.each do |field|
        source.puts "      serializer.serialize(#{field.field_name}, #{field.flags});"
    end

    if type.type_name == "PPtr" && !reduced
        source.puts "      serializer.bindPointer<T1>(*this);"
    end

    if type.type_name == "StreamingInfo"
        source.puts "      serializer.bindExternalAssetData(*this);"
    end

    source.puts "    }";

    header.puts "};";
end

header.puts "}"

unless reduced

    header.puts "namespace UnityAsset::UnityClasses {"

    concrete_implementations = Hash.new { |h, k| h[k] = [] }

    database.classes.each do |classdef|
        chain = classdef
        until chain.nil?
            concrete_implementations[chain].push classdef
            chain = chain.parent_class
        end
    end

    database.classes.each do |classdef|
        ref = nil

        contents = classdef.toplevel
        unless contents.nil?
            ref = compose_type_ref contents, reduced
        end

        name = classdef.sanitized_class_name

        header.write "struct #{name}"

        parent_classes = []

        if concrete_implementations[classdef].size <= 1
            header.write " final"
        end

        if classdef.parent_class.nil?
            parent_classes.push "public Downcastable"
        else
            parent_classes.push "public UnityClasses::#{classdef.parent_class.sanitized_class_name}"
        end

        unless ref.nil?
            parent_classes.push "public virtual #{ref}"
        end

        unless parent_classes.empty?
            header.write ": #{parent_classes.join ", "}"
        end

        header.write <<EOF
{
    static constexpr uint32_t ClassID = #{classdef.class_id};

    #{name}();
    ~#{name}() override;

    int32_t classId() const override;

    bool canBeCastTo(int32_t classId) const override;
EOF

        source.write <<EOF
UnityClasses::#{name}::#{name}() = default;

UnityClasses::#{name}::~#{name}() = default;

int32_t UnityClasses::#{name}::classId() const {
    return ClassID;
}

bool UnityClasses::#{name}::canBeCastTo(int32_t classId) const {
    return classId == ClassID
EOF

        unless classdef.parent_class.nil?
            source.write " || UnityClasses::#{classdef.parent_class.class_name}::canBeCastTo(classId)"
        end

        source.puts ";"
        source.puts "}"

        if !ref.nil? || classdef.parent_class.nil?

            header.puts "  void deserialize(const Stream &stream);"
            source.puts "void UnityClasses::#{name}::deserialize(const Stream &stream) {"
            if ref.nil?
                source.puts "    (void)stream;"
            else
                source.puts "    UnityTypeSerializer::deserializeObject(stream, #{contents.flags}, static_cast<#{ref} &>(*this));"
            end
            source.puts "  }"

            header.puts "  void serialize(Stream &stream);"
            source.puts "  void UnityClasses::#{name}::serialize(Stream &stream) {"
            if ref.nil?
                source.puts "    (void)stream;"
            else
                source.puts "    UnityTypeSerializer::serializeObject(static_cast<#{ref} &>(*this), #{contents.flags}, stream);"
            end
            source.puts "  }"


            header.puts "void link(AssetLinker *asset) override;"
            source.puts "void UnityClasses::#{name}::link(AssetLinker *asset) {"
            if ref.nil?
                source.puts "    (void)asset;"
            else
                source.puts "    UnityTypeSerializer::linkObject(asset, static_cast<#{ref} &>(*this), #{contents.flags});"
            end
            source.puts "}"
        end

        header.puts "};"
    end

    header.puts "}"
end

header.puts "#endif"

source.puts "}"

